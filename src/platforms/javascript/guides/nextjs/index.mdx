---
title: NextJS
sdk: sentry.javascript.nextjs
redirect_from:
  - /platforms/javascript/nextjs/
  - /clients/javascript/integrations/nextjs/
  - /sdks/nextjs/
  - /platforms/nextjs/
description: "Learn how to use Sentry’s NextJS SDK and how it automatically reports errors and exceptions in your application."
---

On this page, we provide concise information to get you up and running with Sentry’s NextJS SDK, automatically reporting errors and exceptions in your application.

<Note>

If you don’t already have an account and Sentry project established, head over to [sentry.io](https://sentry.io/signup/), then return to this page.

</Note>

## Install

To use Sentry with a NextJS application, we will need to use Sentry’s NextJS SDK: `@sentry/nextjs`.
Add it as a dependency using `npm` or `yarn`:

```bash {tabTitle:npm}
npm install --save @sentry/nextjs
```

```bash {tabTitle:Yarn}
yarn add @sentry/nextjs
```

## Configure

Configuration should happen as early as possible in your application’s lifecycle.

You only need to configure the project once, then the created files can go into your version control system.
The default configuration provides frontend and backend error monitoring, Source Maps for both JavaScript and TypeScript, and Vercel deployment support.
Currently, the default config is rather lengthy, but we provide a more automatic way of configuring it.

### Automatic configuration

The call to the [Sentry Wizard](https://github.com/getsentry/sentry-wizard) will automatically patch your project accordingly. It will perform the following changes:

- create `next.config.js` with the default configuration. If such file already exists, it will create `_next.config.js` instead, which will need to be merged manually.
- create `sentry.properties` with Sentry’s project-specific data. This file isn’t required if environment variables are correctly set, see [How to set environment variables for a project](TODO).

```bash
sentry-wizard -i nextjs
```

If you haven’t installed the SDK but want to use the wizard to configure it:

```bash
npx @sentry/wizard -i nextjs
```

### Manual configuration

Firstly, we need to extend NextJS’s usage of webpack by creating a custom `next.config.js` file (if there’s already one, we need to merge it manually):

```javascript {filename:next.config.js}
const {
  NEXT_PUBLIC_SENTRY_DSN: SENTRY_DSN,
  VERCEL_GITHUB_COMMIT_SHA,
  VERCEL_GITLAB_COMMIT_SHA,
  VERCEL_BITBUCKET_COMMIT_SHA,
} = process.env;

const COMMIT_SHA =
  VERCEL_GITHUB_COMMIT_SHA ||
  VERCEL_GITLAB_COMMIT_SHA ||
  VERCEL_BITBUCKET_COMMIT_SHA;

const SentryWebpackPlugin = require('@sentry/webpack-plugin');
const fs = require('fs');

// We require this to fake that our plugin matches the next version
function replaceVersion() {
  const package = require('./package.json');
  if (package && package.dependencies && package.dependencies.next) {
    const packagePluginPath = `./node_modules/@sentry/next-plugin-sentry/package.json`;
    const packagePlugin = require(packagePluginPath);
    packagePlugin.version = package.dependencies.next;
    fs.writeFileSync(packagePluginPath, JSON.stringify(packagePlugin));
  } else {
    console.error(`Can't find 'next' dependency`);
  }
}
replaceVersion();

const basePath = '';

module.exports = {
  experimental: { plugins: true },
  env: {
    SENTRY_DSN: SENTRY_DSN || '___DSN___',
    // Make the COMMIT_SHA available to the client so that Sentry events can be
    // marked for the release they belong to. It may be undefined if running
    // outside of Vercel
    NEXT_PUBLIC_COMMIT_SHA: COMMIT_SHA,
  },
  plugins: ['@sentry/next-plugin-sentry'],
  // Sentry.init config for server-side code. Can accept any available config option.
  serverRuntimeConfig: {
    sentry: {
      // debug: true,
    },
  },
  // Sentry.init config for client-side code (and fallback for server-side)
  // can accept only serializeable values. For more granular control see below.
  publicRuntimeConfig: {
    sentry: {
      // debug: true,
    },
  },
  productionBrowserSourceMaps: true,
  webpack: (config, { dev }) => {
    config.devtool = 'source-map';
    config.plugins.push(
      new SentryWebpackPlugin({
        // Sentry project config
        configFile: 'sentry.properties',
        // webpack specific configuration
        stripPrefix: ['webpack://_N_E/'],
        urlPrefix: `~${basePath}/_next`,
        include: '.next/',
        ignore: ['node_modules', 'webpack.config.js'],
        // dryRun in non-production environments
        dryRun: dev,
        release: COMMIT_SHA,
      }),
    );
    return config;
  },
  basePath,
};
```

If we’re using TypeScript, make sure the compiler generates Source Maps:

```json {filename:tsconfig.json}
{
  "compilerOptions": {
    "sourceMap": true,
  }
}
```

To set Sentry’s project specific data, we can create a `sentry.properties` file, or if you’re interested in using environment variables, see [How to set environment variables for a project](TODO) to avoid creating it:

```properties {filename:sentry.properties}
defaults.org=___ORG_SLUG___
defaults.project=___PROJECT_SLUG___
auth.token=___TOKEN___
```

## Verify

Using the SDK is as simple as just importing it:

```javascript
import * as Sentry from '@sentry/nextjs';
```

We can trigger the first event from our development environment by raising an exception somewhere in the application. For example, throwing an error on a button click:

```JSX
<button onClick={() => {
  throw new Error('First event!');
}}>
  Click me
</button>
```

By logging in to Sentry and opening your project, on the **Issue Details** page, scroll down to the Exception stack trace to view the error, or resolve it.
